import os
import json
from datetime import datetime
from openai import OpenAI

from dotenv import load_dotenv

from .db import DBHandler


class BreachReport:
    """
    Represents a code-of-conduct breach detected in the video annotations.
    
    Attributes:
        rule_id (Optional[str]): The identifier of the breached rule, or None if not provided.
        timestamp (datetime): The time the breach was detected.
        description (str): A brief description of the incident.
    """
    def __init__(self, rule_id: str, timestamp: datetime, description: str):
        self.rule_id = rule_id
        self.timestamp = timestamp
        self.description = description

    def __repr__(self):
        return (
            f"BreachReport(rule_id={self.rule_id}, "
            f"timestamp={self.timestamp.isoformat()}, "
            f"description={self.description})"
        )


class VideoAnalyzer:
    """
    VideoAnalyzer processes video annotations and evaluates them against a set of
    code-of-conduct rules using OpenAI's o1-preview API.
    
    It retrieves camera details (including camera name and code-of-conduct rules)
    via a DB handler, then leverages OpenAI to analyze if any rules are breached.
    """
    def __init__(self, openai_api_key: str = None, db_handler: DBHandler = None):
        """
        Initialize the VideoAnalyzer.
        
        Args:
            openai_api_key (str, optional): Your OpenAI API key. If not provided,
                it will be loaded from the environment variable OPENAI_API_KEY.
            db_handler (DBHandler, optional): A DBHandler instance to retrieve camera details.
                If not provided, a default DBHandler is instantiated.
        """
        if openai_api_key is None:
            load_dotenv()
            openai_api_key = os.getenv("OPENAI_API_KEY")
        if not openai_api_key:
            raise ValueError("A valid OPENAI_API_KEY is required.")

        # Set the API key globally for the openai module
        self.client = OpenAI(api_key=openai_api_key)

        self.db_handler = db_handler if db_handler is not None else DBHandler()

    def analyze(self, annotations: str, camera_id: str):
        """
        Analyze video annotations for potential code-of-conduct breaches.
        
        Args:
            annotations (str): The annotations (or transcript) generated by a VideoAnnotator.
            camera_id (str): The unique identifier for the camera.
        
        Returns:
            list of BreachReport: A list of detected breaches.
            If no breach is detected, an empty list is returned.
        """
        # Retrieve camera details from the DB handler.
        camera_details = self.db_handler.get_camera_details(camera_id)
        camera_name = camera_details.get("camera_name")  # may be None
        rules = camera_details.get("rules", [])

        # Format the rules for inclusion in the prompt.
        rules_text = "\n".join([f"Rule {rule['id']}: {rule['text']}" for rule in rules])

        with open("rules.selected.txt", "w") as f:
            f.write(rules_text)

        # Compose a detailed prompt for the AI.
        prompt = (
            f"You are a video analysis assistant. The following is a description of events "
            f"from camera '{camera_name}'. Check if any actions breach the code-of-conduct rules provided.\n\n"
            f"Video Annotations:\n{annotations}\n\n"
            f"Code-of-Conduct Rules:\n{rules_text}\n\n"
            "For each breach detected, output a JSON object with two keys: "
            "'rule_id' (the ID of the breached rule) and 'description' (a brief explanation of the incident). "
            "Return a JSON array of such objects. If no breach is detected, return an empty JSON array. Make sure you catch breaches from code-of-conduct rules."
        )

        # IMPORTANT:
        # The o1-preview model does not support messages with role "system",
        # so we only send a single user message.
        response = self.client.chat.completions.create(model="o1-preview",
        messages=[
            {"role": "user", "content": prompt}
        ])
        response_content = response.choices[0].message.content.strip()

        # Parse the JSON response.
        try:
            breach_list = json.loads(response_content)
        except json.JSONDecodeError:
            breach_list = []

        # Convert each breach into a BreachReport object.
        current_time = datetime.now()
        reports = []
        for breach in breach_list:
            # Use None if rule_id is missing.
            rule_id = breach.get("rule_id")
            description = breach.get("description", "")
            reports.append(BreachReport(rule_id, current_time, description))

        return reports